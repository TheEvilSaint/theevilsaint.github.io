---
layout: post
title: 'Credential Dumping'
date: '2021-06-17'
description: ''
coverimage: throw.jpg
tags: 
published: true
posttype: article
categories: article
---
Sam database
 local Windows credentials are stored in the security account manager or Sam database as password hashes using the nclm hashing format which is based on the MD for algorithm we can reuse acquired nclm hashes to authenticate to a different machine as long as the hash is tied to a user account and password registered on that machine although it's rare to find matching local credentials between disparate machines the built-in default named administrator account is installed on all windows based machines this account has been disabled on desktop editions since Windows Vista but it is enabled on servers by default
 to ease administrative task system administrators often enable this default account on desktop editions and set a single shared password given the capability of this attack Vector let's walk through an example
 in this case will attack the default local administrator account
 every Windows account has a unique security identifier or SID that follows a specific pattern
 in this structure the seed begins with a literal ass to identify the string is a sid followed by a revision level usually set to 1 and identify Authority value often five and one or more sub of 30 values the sub Authority will always end with a relative identifier or or Friday representing a specific object on the machine
 let's use Powershell nwmi to locate the seed of the local administrator account on our Windows 10 victim machine
 let's use Powershell and wmi to locate the seed of the local administrator account on our Windows 10 victim machine
 first we'll determine the local computer name from the associated environment variable
 and use it with the wmi win32 user account class
 to obtain results for the local administrator account will specify the computer name through the domain property
 and the account name through the name property
 the output reveals in r i d value of 500 as expected
 next will attempt to obtain credentials for this user account from the Sam database
 the Sam database is located at C Windows system32 config Sam but the system process has an exclusive lock on it
 preventing us from reading or copying it even from an administrative command prompt
 there are two potential workarounds
 first we could use the volume Shadow copy server which can create a snapshot or Shadow volume of the local hard drive with vssadmin which is installed on Windows 8.1 and later we can create a new Shadow volume with the create Shadow option but this option is only available on server editions of the school the second approach which will work on our Windows 10 machine is to execute this option through wmic launched from an administrative command prompt specifically it will launch wmic specify the shadow copy class
 create a new Shadow volume and specify the source drive with volume equals
 this will create a snapshot of the C drive
 to verify this will run vssadmin and list the existing Shadow volumes with list Shadows
 now that we've confirmed the creation of the Shadow volume we can copy the Sam database from it using the source path provided in the output
 although we have copied the Sam database it is partially encrypted by either rc4 or AES
 the encryption keys are stored in the system file which is in the same folder as the Sam database however it is also locked by the system account
 we can reuse our shadow volume copy to copy this file as well
 we can also obtain a copy of the Sam database and system files from the registry in the H key local machine Sam and hkey local machine system hives respectively administrative permissions are required to read and copy
 for example will use the reg save command to save the content to the hard disk by specifying the registry hive
 and the output file name and path
 regardless of how we obtained the Sam database and system file we must decrypt them
 at the time of this video the only two tools that can decrypt these files are Mimi cats and credit dump 7 in this example will use credit dump first will install the python crypto library and then clone cred dumped from the GitHub repository with Git clone
 at the time of this video the only two tools that can decrypt these files are Mimi cats and credit seven in this example will use credum first will install the python crypto library and then clone cred dumped from the GitHub repository with Git clone
 next will copy the Sam and system files from the Windows 10 victim machine to our Kali Linux machine
 and use the PW dump python script from Craig dump 7 to decrypt the ntlm hashes
 we have successfully decrypted the Sam database and obtain the ntlm password hash for the local administrator account
 in this section we have executed this process manually to demonstrate the individual steps however many post exploitation Frameworks can automate this process as well
 in the next section will examine how Microsoft has attempted to mitigate the risk of this attack vector
hardening the local administrator account
 although disabling this account would block this attack Vector many organizations rely on this account for various applications and administrative tasks in an attempt to prevent attacks that leverage shared administrator passwords Microsoft introduced Group Policy preferences with Windows Server 2008 which included the ability to centrally change local administrator account passwords however this approach stored data in an XML file in a cyst fall folder which must be accessible to all computers in active directory
 this created an obvious security issue since the unhash local administrator password was stored on an easily accessible share to solve this issue Microsoft aes-256 and Cryptid them the aes-256 encryption password is realistically unbreakable given a strong key
 this created an obvious security issue since the unhash the local administrator password was stored on an easily accessible share to solve this issue Microsoft aes-256 and Cryptid them the aes-256 encryption password is realistically unbreakable given a strong key
 surprisingly Microsoft published the AES private key on msdn effectively breaking their own encryption
 as an apparent solution Microsoft issued a security update in 2014 which removed the ability to create group policy preferences containing passwords although these files could no longer be created existing Group Policy preferences containing passwords were not removed meaning some may still exist in the wild to again address the issue of centrally managing passwords for the local administrator account Microsoft released the local administrator password solution or laps in 2015 which offered a secure and scalable way of remotely managing the local administrator password for domain-joined computers laps introduces two new attributes for the computer object into active directory the first registers the expiration time of a password as directed through a group policy
 the second contains the cleartext password of the local administrator account
 this attribute is confidential meaning specific read permissions are required to access the content which is normally assigned through group membership lapse uses the unmanaged dynamic link library admp wdll to change the local administrator password and push the new password to the second attribute of the associated computer object
 if lapses in use we should try to gain access to the clear text passwords in active directory as part of a penetration test
 is lapses in use we should try to gain access to the clear text passwords in active directory as part of a penetration test
 while Microsoft has released a Powershell toolkit to query lapse it is not typically installed on a workstation
 while Microsoft has released a Powershell toolkit to query lapse it is not typically installed on a Workstation
 instead we can use the laps toolkit Powershell script which is essentially a rapper script around the Power view active directory enumeration Powershell script
 for example will invoke the get laps computers method from laps toolkit to list all computers which are set up with laps and display the hostname the clear text password and the expiration time
 although we have discovered the app serves 01 server which is managed by elapsed we cannot view the clear text password
 in this case our current user account does not have permissions to read the password so it's returned as empty we can use the find laps delegated groups method of laps toolkit to discover groups that can fully enumerate the lapse data
 from the output we find that members of the custom laps password readers group have read permissions
 next week and use powerview to enumerate members of that group through the get net group member method
 supplying the group name option to specify the group name
 the output reveals that the Jeff and admin users can read the laps passwords
 these permissions are often given to both help desk employees and system administrators users with these permissions are prime targets during a penetration test since they have access to clear text passwords on a potentially large number of workstations or servers
 for example we start a Powershell instance as the admin user
 and view the laps passwords with get laps computers
 we can use the local administrator password for App serves your one to remotely log into this machine and others with matching credentials
 now that we have an understanding of the local administrator account and potential attack vectors against it let's investigate how access rights and permissions work after a user has authenticated on Windows
access tokens
 credentials such as username and password combinations are used for authentication but the operating system also must keep track of the users access rights for example authorization Windows users access tokens to track these rights and their assigned to each process associated with the user in this section will discuss access tokens and explore various ways we can leverage them for privilege escalation
 credentials such as username and password combinations are used for authentication with the operating system also must keep track of the users access rights for example authorization Windows users access tokens to track these rights and their assigned to each process associated with the user in this section will discuss access tokens and explore various ways we can leverage them for privilege escalation
access token Theory
 an access token is created by the colonel upon user authentication and contains important values that are linked to a specific user through the Sid access tokens are stored inside the kernel which prevents us from directly interacting with the token or modifying it as penetration testers will focus on two concepts relating to the access token specifically Integrity levels and privileges Windows defines for integrity levels which determine the level of access low medium high and system
 low Integrity is used with sandbox processes like web browsers applications executing in the context of a regular user run at medium integrity and administrators can execute applications at high integrity system is typically only used for system Services it's not possible for a process of a certain Integrity level to modify a process of hire Integrity level but the opposite is possible this is done to prevent trivial privilege escalation local administrators received to access tokens when authentication the first which is used by default is configured to create processes as medium Integrity when the user selects the run as administrator option for an application II elevated token is used instead and allows the process to run at high integrity
 the user account control or UAC mechanism links these two tokens to a single user and creates the consent prompt a local administrator regulated by UAC is sometimes also called a split token administrator privileges are also included in the access token they are a set of predefined operating system access rights that govern which actions of process can perform within the access token privileges are controlled by two-bit masks the first sets the Privileges which are present for that specific token and cannot be modified through any apis inside the same logon session II registers if the present privileges are enabled or disabled and may be dynamically updated through the win32 API adjust token privileges
 for example we can easily view the available privileges for the current user with who am I from command. Exe by specifying the / flag the output shows five privileges although we won't discuss every privilege let's discuss token privilege modification the SEC shut down privilege privilege allows the user to reboot or shut down the computer since it is listed in the output it is present in the access token but it is also disabled if we choose to shut down the computer through the shutdown command the backend code will enable the privilege with adjust token privileges
 for example we can easily view the available privileges for the current user with who am I from command. Exe by specifying the / flag the output shows five privileges although we won't discuss every privilege let's discuss token privilege modification the SE shutdown privilege privilege allows the user to reboot or shut down the computer since it is listed in the output it is present in the access token but it is also disabled if we choose to shut down the computer through the shutdown command the backend code will enable the privilege with adjust token privileges
 and then perform the required actions to power off the operating system while it is impossible to modify the set of privileges that are associated with an active log on session it is however possible to add additional privileges that will take effect after the targeted user account logs out and log back in programmatically this can be done with the win32 API LSA add account rights but more often it would be performed through a group policy or locally through an application like secpol. MSC
 and then perform the required actions to power off the operating system while it is impossible to modify the set of privileges that are associated with an active log on session it is however possible to add additional privileges that will take effect after the targeted user account logs out and log back in programmatically this can be done with the win32 API LSA add account rights but more often it would be performed through a group policy or locally through an application like SEC Paul. MSC
 selected privilege SE load driver privilege yields the permission to load a kernel driver if we were to apply that privilege to our user the current token would not be modified rather a new token would be created once the user logs out and back in again
 as we wrap up this theoretical section we must discuss two types of access tokens each process has a primary access token which originates from the user's token created during authentication in addition and impersonation token can be created which allows a user to act on behalf of another user without that users credential impersonation tokens have four levels Anonymous identification impersonation and delegation
 as we wrap up this theoretical section we must discuss two types of access tokens each process has a primary access token which originates from the user's token created during authentication in addition and impersonation token can be created which allows a user to act on behalf of another user without that users credentials impersonation tokens have four levels Anonymous identification impersonation and delegation
 Anonymous an identification only allow enumeration of information impersonation as the name implies allows impersonation of the client's identity while delegation makes it possible to perform sequential Access Control checks across multiple machines the ladder is critical to the functionality of distributed applications for example let's assume a user authenticate to a web server and performs an action on that server that requires a database look up the web server could use delegation to pass authentication to the database server through the web server now that we've discussed the main theory behind Windows post off an occasion permissions and access rights will practically apply this theory in the next section
elevation with impersonation
 in the previous section we discussed how the Privileges of an access token decide the access rights of an authenticated user
 now let's discuss how we can leverage certain privileges for escalation in the past security researchers have identified nine different privileges that may allow for privilege escalation from medium Integrity to either high integrity or system Integrity or enable compromise of processes running as another authenticated user explaining all 9 privileges in depth and how they may be used to escalate privileges is beyond the scope of this module but will focus on SE impersonate privilege this privilege allows us to impersonate any token for which we can get a reference or handle SE in person a privilege is quite interesting since the built-in network service account the local service account and the default is account
 now let's discuss how we can leverage certain privileges for escalation in the past security researchers have identified nine different privileges that may allow for privilege escalation from medium Integrity to either high integrity or system Integrity for an able compromise of processes running as another authenticated user explaining all 9 privileges in depth and how they may be used to escalate privileges is beyond the scope of this module but will focus on SE impersonate privilege this privilege allows us to impersonate any token for which we can get a reference or handle SE in person a privilege is quite interesting since the built-in network service account the local service account and the default is account
 assigned by default because of this gaining code execution on a web server will often give us access to this privilege and potentially offer the possibility to escalate our access if we have SE in-person a privilege we can often use the duplicate token X win32api to create a primary token from an impersonation token and create a new process in the context of the impersonated user when no tokens related to other user accounts are available in memory we can likely Force the system account to give us a token which we can impersonate to leverage as the impersonate privilege in this section we're going to use a post exploitation attack that relies on Windows pipes pipes are a means of inner process communication just like our PC cam or even network sockets
 I've been assigned by default because of this gaining code execution on a web server will often give us access to this privilege and potentially offer the possibility to escalate our access if we have SE impersonate privilege we can often use the duplicate token X win32api to create a primary token from an impersonation token and create a new process in the context of the impersonated user when no tokens related to other user accounts are available in memory we can likely Force the system account to give us a token which we can impersonate to leverage as the impersonate privilege in this section we're going to use a post exploitation attack that relies on Windows pipes pipes are a means of inner process communication just like our PC cam or even network sockets
 a pipe is a section of shared-memory inside the colonel that processes can use for communication one process the pipe server can create a pipe while other processes pipe clients can connect to the pipe and read or write information from or to it depending on the configured access rights for a given height Anonymous pipes are typically used for communication between parent and child processes while named pipes are more broadly used in our example will make use of named pipes because they have more functionality and more importantly they support impersonation the attack that we're going to stimulate based on a technique developed by security researcher Lee Christensen can force the system account to connect to a named pipe set up by an attacker
 a pipe is a section of shared-memory inside the colonel that processes can use for communication one process the pipe server can create a pipe while other processes pipe clients can connect to the pipe and read or write information from or to it depending on the configured access rights for a given height Anonymous pipes are typically used for communication between parent and child processes while named pipes are more broadly used in our example will make use of named pipes because they have more functionality and more importantly they support impersonation the attack that we're going to stimulate based on a technique developed by security researcher Lee Christensen can force the system account to connect to a named pipe setup by an attacker
 while the technique was originally developed as part of an active directory attack it can also be used locally it's based on The Print Spooler service which is started by default and run in a system context will discuss the technique in more detail later for now it's important to understand that the attack is based on the fact that the Print Spooler monitors printer object changes and sends change notifications to print clients by connecting to their respective named pipes if we can create a process running with the SE impersonate privilege that simulates a print client we will obtain a system token that we can impersonate to demonstrate this let's create a C sharp application that creates a pipe server weights for a connection and attempts to impersonate the client that connects to it
 the first key component of this attack is the impersonate named pipe client API which allows impersonation of the token from the account that connects to the pipe if the server has se impersonate privilege when impersonate named pipe client is called the calling thread will use the impersonated token instead of its default token in order to create our first proof-of-concept will have to use the create named pipe connect named pipe and impersonate named pipe client 32 apis
 as the name suggests create named pipe creates a pipe is API except the number of relatively simple arguments the first and most important is the pipe name all named pipes must have a standardized name format and must be unique on the system the second argument describes the mode the pipe is opened in
 will specify a bi-directional pipe with the pipe access duplex enum using its numerical equivalent of 3 the third argument describes the mode the pipe operates in will specify pipe type bite to directly write and read bites along with pipe wait to enable blocking mode
 this will allow us to listen on the pipe until it receives a connection will specify the combination of these two modes with the numerical value zero the maximum number of instances for the pipe is specified through nmax instances this is primarily used to ensure efficiency and larger applications and any value between 1 and 2:55 works for us in out buffer size and an in buffer size Define the number of bikes to use for the input and output buffer respectively will choose one memory page of hacks 1,000 bytes the second to last argument defines the default timeout value that is used with the weight named pipe API
 since we're using a blocking named pipe we don't care about this and we can choose the default value of 0 for the last argument we must submit a sid detailing which clients can interact with the pipe will set this to know to allow the system and local administrators to access it
 at this point will create a new Visual Studio solution
 and insert the P invoke dllimport statement along with the call to create named pipe
 and insert the p in Boca dllimport statement along with the call to create named pipe
 this code expects the pipe name to be passed on the command line
 next we must invoke connect named pipe the first argument is a handle to the pipe which is returned by create named pipe and the second is a pointer to a structure used in more advanced cases in our case will simply set this to know
 next we add the code required to import and call connect named pipe
 after we've called connect named pipe the application will wait for an incoming pipe client
 once the connection is made will call impersonate named pipe client to impersonate the client impersonate named pipe client accept the pipe handle as it's only argument or its function prototype
 once the connection is made will call impersonate named pipe client to impersonate the client impersonate named pipe client accepts the pipe handle as it's only argument or its function prototype
 the rather simple code editions importing and calling impersonate named pipe client are added next
 at this point our code will start a pipe server listen for incoming connections and impersonate them if everything works correctly impersonate named pipe client will assign the impersonated token to the current thread but we have no way of confirming this in our current application to verify the success of our attack we can open the impersonated token with open thread token and then use get token information to obtain the Sid associated with the token finally we can call convert Sid to string Sid to convert the Sid to a readable Sid string while this confirmation does not have to be part of our final exploit it helps us understand the attack let's add these apis to Arco let's examine the function prototype for open thread token
 according to the function prototype we must First Supply a handle to the thread associated with this token
 since the thread in question is the current thread will use the get current thread win32api which does not require any arguments and simply Returns the handle next we must specify the level of access we went to the Token to avoid any issues will ask for all permissions with its numerical value
 since the threat in question is the current thread will use the get current thread win32api which does not require any arguments and simply Returns the handle next we must specify the level of access we went to the Token to avoid any issues will ask for all permissions with its numerical value
 open a self specifies whether the API should use the security context of the process or the thread since we want to use the impersonated token will set this to false finally we must Supply a pointer that will be populated with a handle to the Token that is opened
 open a self specifies whether the API should use the security context of the process or the thread since we want to use the impersonated token will set this to fall so finally we must Supply a pointer that will be populated with a handle to the Token that is opened
 let's add the required code
 next will invoke get token information
 the API can return a variety of information but will simply request this Sid the first argument is the token we obtained from open thread token and the second argument specifies the type of information we want to obtain token information class isn't enough that contains value specifying the type of information we can retrieve from an access token via get token information since we simply want the CID we can pass token user which has the numerical value of one for the token information class argument token information is a pointer to the output buffer that will be populated by the API
 the API can return a variety of information but we'll simply request this Sid the first argument is the token we obtained from open thread token and the second argument specifies the type of information we want to obtain token information class isn't enough that contains value specifying the type of information we can retrieve from an access token via get token information since we simply want the CID we can pass token user which has the numerical value of one for the token information class argument token information is a pointer to the output buffer that will be populated by the API
 and token information length is the size of the output buffer since we don't know the required size of the buffer the recommended way of using the API is to call it twice the first time we set these two argument values to know and 0 respectively and then return length will be populated with the required size
 after this we can allocate an appropriate buffer and call the API a second time
 to allocate the token information buffer will use the dotnet Marshall Alec H Global method which can allocate unmanaged memory
 as the final step will use convert Sid to string CID to convert the binary CID to a CID string which we can read the first argument is a pointer to the Sid the Sid is in the output buffer that was populated by get token information but we must extract it first one way to do this is to define the token user structure which is part of the token information class used by get token information and then Marshall a pointer to it with Marshall pointer to structure for the last argument will supply the output string here we can simply Supply in empty pointer and once it gets populated Marshall it to see Sharp string with Marshall pointer to string Auto
 as the final step will use convert Sid to string Sid to convert the binary Sid to a CID string which we can read the first argument is a pointer to the Sid the Sid is in the output buffer that was populated by get token information but we must extract it first one way to do this is to define the token user structure which is part of the token information class used by get token information and then Marshall a pointer to it with Marshall pointer to structure for the last argument will supply the output string here we can simply Supply in empty pointer and once it gets populated Marshall it to see Sharp string with Marshall pointer to string Auto
 let's add the required structures
 import
 and code
 on the last line of code we print the CID associated with the token to the console showing which user we impersonated now we have finally written all the code we need to test and better understand the use of named pipes for impersonation and privilege escalation
 on the last line of code we print the sea associated with the token to the console showing which user we impersonated now we have finally written all the code we need to test and better understand the use of named pipes for impersonation and privilege escalation
 as previously mentioned we must execute the code in the context of a user account that has the SE impersonate privilege access right
 for our attack demonstration will log into app server 01 as the domain user admin
 for our attack demonstration will log into app serves 01 as the domain user admin
 and use PS exact to open a command prompt as the built-in network service account
 before we execute our application we can verify the user and the presence of SE impersonate privilege in the new command prompt
 now we can transfer it to app serves 01
 next we executed and Supply a random pipe name
 simulator connection we can open an elevated command prompt and write to the pipe
 when we switch back to the command prompt running our application
 we find that a CID has been printed our code has impersonated a token and resolved the associated Sid to verify that this Sid belongs to the administrator account we can switch back to the elevated command prompt and dump it
 this proves that we have indeed impersonated the built-in domain administrator account more importantly we can impersonate anyone who connects two are named pipe
 it's now time to test her application leveraging The Print Spooler service communication to the spooler service is done through print system remote protocol which dates back to 2007 and is not well documented fortunately for us the MSRP RN Works through named pipes the potential for abuse comes from the RPC open printer and our PC remote find first printer change notification functions
 our PC open printer allows us to retrieve a handle for the printer server which is used as an argument to the second API
 our PC remote find first printer change notification essentially monitors printer object changes and sends change notifications to print clients
 once again this change notification requires the principal or to access the print client if we ensure that the print client is are named pipe it will obtain a system token that we can impersonate sadly unlike regular win32api MSRP RN apis cannot be called directly principal or functionality resides in an unmanaged library and is called through a proxy function
 once again this change notification requires the principal or to access the print client if we ensure that the print client is are named pipe it will obtain a system token that we can impersonate sadly unlike regular win32api MSRP RN apis cannot be called directly principal or functionality resides in an unmanaged the library and is called through a proxy function
 that uses a binary format to pass and invoke underlying functions
 the implementation of these calls are beyond the scope of this module luckily we can use the spool sample C sharp implementation written by Lee Christensen or the Powershell code written by Vincent Le 2
 when we use School sample we must specify the name of the server to connect to and the name of the server we control also called the capture server
 since we're performing the attack locally both servers are the same
 this presents a challenge The Print Spooler service running as system on the victim needs to contact the simulated print client through our pipe but since they're on the same hoes they in effect required the same pipe name because of this we cannot create the name pipe with the required name in order to find a solution we first must understand the problem in detail to do this we'll monitor the target system with sysinternals process monitor while executing spool sample. Exe against an arbitrary hype name
 first will configure capture filter with filter filter and select process name from the drop-down menu setting this to spool serve. Exe will then click add followed by a plaid and exit the filter menu by selecting okay
 then we'll execute spool sample and specify the current host name followed by an arbitrary named pipe
 although the application output indicates that a printer notification callback was configured process monitor shows that no access to the arbitrary pipe name has occurred the reason for this is that before attempting to access the client pipe The Print Spooler service validates the pipe path making sure it matches the default name
 our arbitrary pipe test fails this validation and consequently The Print Spooler service doesn't even attempt to connect to the client this is why we don't see any connections in process monitor unfortunately as mentioned before we cannot specify spool SS as a name since it's already in use by The Print Spooler service we're targeting
 at this point it's useful to know what happens when a file path is supplied to a win32api when directory separators are used as part of the file path they are converted to canonical form specifically forward slash has will be converted to backwards lashes this is also known as file path normalization interesting Lee enough a security researcher discovered that if we provide spool sample with an arbitrary pipe name containing a forward slash after the host name
 the spooler service will not interpret it correctly and it will depend the default name to our own path before processing it this effectively bypasses the path validation and the resulting path is then normalized before the spooler service attempts to send a print object change notification message to the client
 this can obviously help us because the pipe name differs from the default name used by The Print Spooler service and we can register it to stimulate a print client
 to verify this we can repeat our last example this time supplying an arbitrary pipe name that contains a forward slash in the print client name
 we receive an error
 and process monitor confirms the theory first the path we supplied has been switched to a canonical form as part of the full path II spool serve. Exe attempted to access the named pipe
 since we have not created a pipe server by that name the request failed at this point we just need to create a pipe server with that name and simulate a print client when we execute spool sample The Print Spooler service will connect to our pipe
 did you this will open another command prompt as network service because we're demonstrating a scenario where we've exploded a process that has the SE in person a privilege and we're trying to escalate to system
 and launch our application
 now will invoke spool sample to trigger the change notification against the capture server
 our application reveals a connection from the S15 18 CID
 or application reveals a connection from the S15 18 CID
 this Sid value belongs to the system account proving that our technique worked excellent we now have a way of forcing the system account to authenticate to our named pipe which allows us to impersonate it
 this Sid value belongs to the system account proving that our technique worked excellent we now have a way of forcing the system account to authenticate to our names pipe which allows us to impersonate it
 you complete this attack we must now take advantage of the impersonated token which we will do by first launching a command prompt as system
 the win32 create process with token wapi can create a new process based on a token
 the token must be a primary token so will first use duplicate token X to convert the impersonation token to a primary token first will supply the impersonation token by recovering it with open thread token will request full access to the token with the numerical value hex f01 ff4 the d w desired access argument for the third argument will use a default security descriptor for the new token by setting this to know
 impersonation level must be set to security impersonation which is the access type we currently have to the Token this has a numerical value of 2 for the token type will specify a primary token by setting this to won the final argument is a pointer that will be populated with the handle to the duplicated token
 what's a token duplicated as a primary token we can call create process with token to create a command prompt as system
 with the token duplicated as a primary token we can call create process with token to create a command prompt as system
 first we'll Supply the newly duplicated token followed by a log on option which we set to its default of 0 for the third and fourth arguments will supply and the full path of cmd.exe respectively
 the creation Flags environment block and current directory arguments can be set to 0 no and no respectively to select the default option for the last two arguments we must pass start up info and process information structures which are populated by the API during execution
 the creation Flags environment block and Corinth directory arguments can be set to 0 no and no respectively to select the default option for the last two arguments we must pass start up info and process information structures which are populated by the API during execution
 neither of these are defined in p and VOC Imports so we must Define them ourselves as shown in the following code
 with all the code written will compile it
 and transfer it to the Windows Server 2019 machine
 will execute this just as before my first a launching or application in the context of the network service to create the pipe server on app serves 01
 will execute this just as before by first a launching or application in the context of the network service to create the pipe server on app serves 01
 next will launch spool sample with the capture server set to app serves 01 pipe test which will force the system account to connect to our names pipe and a new command prompt is opened
 next will launch spool sample with the capture server set to app serves 01 height test which will force the system account to connect to our names pipe and a new command prompt is opened
 when we interact with it and display the user we find it to be system
 with this attack we can Elevate our privileges from a nun privileged account that has se impersonate privilege to system on any modern window System including Windows 2019 and the newest versions of Windows 10 nice
 with this attack we can Elevate our privileges from a nun privileged account that has se impersonate privilege II system on any modern window System including Windows 2019 and the newest versions of Windows 10 nice
 most native and third-party services that do not require administrative permissions run as network service or local service partly due to Microsoft's recommendation this attack technique means that compromising and unprivileged service is just as valuable as a system service
 in the next section will demonstrate how to impersonate tokens from other authenticated users instead of Simply advancing straight to system
fun with incognito
 in this section will use the matter printer Incognito module to impersonate any logged-in users and obtain code execution in their contacts without access to any passwords for hashes although we'll use Mimi cats to collect Kerberos authentication credentials later in this module this access token attack Vector does not rely on Mimi cat and may evade some detection software
 to demonstrate this will authenticate to app serves 01 as the admin user through remote desktop
 and leave The Connection open
 will then switch to a system Integrity meterpreter shell next will load the Incognito extension through the load command
 will then switch to a system Integrity meterpreter shell next will do the Incognito extension through the load command
 and run help to display available commands
 will focus on list tokens - you which will list all currently used tokens by unique username
 the output reveals a delegation token for the admin domain user next will run impersonate token to impersonate the admin user through the impersonate logged on user API to invoke it we must specify the username of the token we want to impersonate
 the output shows that we were able to impersonate the admin domain user from a delegation token which will allow us to perform actions on this server and authenticate against remote computers in the context of that user
 with this approach we have impersonated a user within a mature Porter shell without writing to disk
Kerberos and domain credentials
 in an active directory implementation Kerberos handles most user and Integrated Service authentication in the following sections will explore how the Kerberos protocol is implemented in Windows and how we can leverage it for credential stealing
Kerberos Authentication
 the Microsoft implementation of the Kerberos Authentication Protocol was adopted from the Kerberos version 5 Authentication Protocol developed by MIT and has been Microsoft primary authentication mechanism since Windows Server 2003 while ntlm authentication Works through a principle of Challenge and response windows-based Kerberos authentication uses a ticket system at a high-level Kerberos client authentication to a service in active directory involves the use of a domain controller in the role of a key distribution center or KDC
 let's review this process in detail in order to lay a foundation for discussion in the following section when the user logs in a request is sent to the domain controller or DC
 this DC serves as a k DC and runs the authentication server service the initial authentication server request contains a timestamp encrypted using a hash derived from the current user username and password when the service receives the request it looks up the password hash associated with that user and attempts to decrypt the timestamp if the decryption process is successful and the timestamp is not a duplicate the authentication is considered successful the service replies to the client with an authentication server reply which contains a session key since her berosus stateless and a ticket granting ticket or TGT
 this DC serves as a k DC and runs the authentication server service the initial authentication server request contains a timestamp encrypted using a hash derived from the current user username and password when the service received the request it looks up the password hash associated with that user and attempts to decrypt the timestamp if the decryption process is successful and the timestamp is not a duplicate the authentication is considered successful the service replies to the client with an authentication server reply which contains a session key since her borrosas stateless and a ticket granting ticket or TGT
 the session key is encrypted using the user's password hash which the client could decrypt and reuse the TGT contains user information including memberships the domain a timestamp the IP address of the client and the second key in order to avoid tampering the ticket granting ticket is encrypted by a secret key known only to the ktc and cannot be decrypted by the client once the client has received the session key and the TGT the ktc considers the client authentication complete by default the TGT will be valid for 10 hours during this time the user is not required to retype the password additionally the TGT can be renewed without entering the password when the user attempt to access domain resources such as a network share exchange mailbox or some other application with a registered service
 the second key is encrypted using the user's password hash which the client could decrypt and reuse the TGT contains user information including memberships the domain a timestamp the IP address of the client and the session key in order to avoid tampering the ticket granting ticket is encrypted by a secret key known only to the ktc and cannot be decrypted by the client once the client has received the session key and the TGT the ktc considers the client authentication complete by default the TGT will be valid for 10 hours during this time the user is not required to retype the password additionally the TGT can be renewed without entering the password when the user attempts to access domain resources such as a network share exchange mailbox or some other application with a registered service
 people named or SPN the ktc is again contacted this time the client constructs a ticket granting service request packet that consists of the current user and a timestamp encrypted using the second key the ESPN of the resource and the encrypted TGT
 possible name or SPN the ktc is again contacted this time the client constructs a ticket granting service request packet that consists of the current user and a timestamp encrypted using the second key the ESPN of the resource and the encrypted TGT
 next the ticket granting service on the ktc receives the ticket granting service request and if the ESPN exist in the domain the TGT is decrypted using the secret key known only to the Katy see the session key is that extracted from the decrypted TGT and this key is used to decrypt the username and time stamp of the request if the TGT has a valid timestamp where no replay is detected and the request is not expired the TGT and session key usernames match and the origin and TT IP addresses match the request is accepted if this succeeds the ticket granting service response to the client with a ticket granting server reply
 next the ticket granting service on the ktc receives the ticket granting service request and if the ESPN exist in the domain the TGT is decrypted using the secret key known only to the Katy see the session key is an extracted from the decrypted TGT and this key is used to decrypt the username and time stamp of the request if the TGT has a valid timestamp where no replays detected and the request is not expired the TGT and session key usernames match and the origin and TT IP addresses match the request is accepted if this succeeds the ticket granting service response to the client with a ticket granting server reply
 this packet contains three parts the ESPN to which access has been granted a session key to be used between the client and the ESPN and a service ticket containing the username and memberships along with the newly-created session key
 the first two parts the SPN in the session key are encrypted using the session key associated with the creation of the TGT and the service ticket is encrypted using the password hash of the service account registered with the target SPN once the authentication process with the ktc is complete and the client as both a session key and a service ticket service authentication begins first of the client sends an application request which includes the username and a timestamp encrypted with the session key associated with the service ticket along with the service ticket itself
 the first two parts the SPN in the session key are encrypted using the session key associated with the creation of the TGT and the service ticket is encrypted using the password hash of the service account registered with the target SPN once the authentication process with a k t c is complete and the client as both a session key and a service ticket service authentication begins 1st to the client sends an application request which includes the username and a timestamp encrypted with the session key associated with the service ticket along with this service ticket itself
 the service decrypts the service ticket using its own password hash extracts the session key from it and the Crips the supplied username if the usernames match the request is accepted before access is granted the service inspects the Supply Group memberships in the service ticket and the signs appropriate permissions to the user after which the user may make use of the service as required
 this protocol may seem complicated and perhaps even convoluted but it was designed to mitigate various Network attacks and prevent the use of fake credentials
 now that we've explored the foundations of Kerberos authentication let's look at how we can dump cached credentials with Mimi cats
meaning cats
 in this section will discuss how many cats can be used to extract credentials from memory due to cashing requirements of the Kerberos protocol will also discuss local security Authority protection and how it can be bypassed due to the automatic renewal of tgt's password hashes are cashed in the local security Authority subsystem service or else ass memory space
 if we gain access to these houses we could crack them to obtain the clear text password or reuse them to perform various actions which will discuss in a later module since Alsace is part of the operating system and runs as system we need system or local administrator permission to gain access to the hashes stored on a Target in addition to data structures are not publicly documented and they are encrypted with an elsass stored key Mimi cats is a powerful tool that we can use to extract and manipulate credentials tokens and privileges in Windows in this section will specifically use it to dump cash domain credentials and use it for other purposes later in this module
 after launching Mimi cats from an elevated command prompt on a Windows 10 victim machine will have to tamper with the memory of the elsass process which is normally not allowed since it belongs to the system user and not the current offsec user however as administrator the offsec user can use SE debug privilege to read and modify a process under the ownership of a different user
 did you this will use the mini cats privilege debug command to enable the SE debug privilege by calling adjust token privileges
 once we have enabled the SE debug privilege will dump all cashed passwords and hatches from else asked with Secor LS a log on passwords
 the inner workings of the commander quite complex and Beyond the scope of this module due to the inherent encryption and undocumented structures employed by elsass but the results show the ntlm hash of the opsec domain user
 since 2012 when we make hats was released and cash credential dumping was popularized Microsoft has developed mitigation techniques LS a protection and Windows Defender credential guard in this module will focus on LS a protection as previously mentioned Windows divides its processes into four distinct Integrity levels an additional mitigation level protected processes light PPL was introduced from Windows 8 on Words which can be layered on top of the current Integrity level
 in essence this means that a process running at system Integrity cannot access or modify the memory space of a process executing at system Integrity with PPL enabled
 to demonstrate this will log into the windows 2019 server app serves 01 as the admin user
 this is done through the run as ppld word value in hkey local machine system current control set control LS a with a value of 1
 this is done through the run as ppld word value in hkey local machine system current control set control LSA with a value of 1
 this protection mechanism is disabled by default due to third-party compatibility issues on absurd 01 LS a protection has already been configured
 this protection mechanism is disabled by default due to third-party compatibility issues on app serves 01 LS a protection has already been configured
 when elsass is executing as a protected process light Mimi cats failed due to insufficient permissions
 the sicurella say log on passwords command Returns the access denied error value PPL protection is controlled by a bit residing in the eprocess kernel object associated with the target process
 if we could obtain code execution in Colonel space we could disable the LSA protection and dump the credentials luckily this can be achieved with Mimi cats since it comes bundled with the me me Dr. Sis driver we must be local administrator or system to dump the credentials which means we will also have the SE load driver privilege and the ability to load any signed drivers many cats can load the me me Dr. Sis driver with the bang plus command
 if we could obtain code execution in Colonel space we could disable the LSA protection and dump the credentials luckily this can be achieved with Mimi cats since it comes bundled with a Mimi Dr. Sisques driver we must be local administrator or system to dump the credentials which means we will also have the SE load driver privilege and the ability to load any signed drivers many cats can load the me me Dr. Sis driver with the bang plus command
 once the driver is loaded we can use it to disable to PPL protection for elsass through the process protect command while supplying the / process option to specify the name of the process
 and the remove flag to disable PPL
 while this technique will disable dlsa protection it does require that we upload the Mimi Dr. Sis driver to the victim machine which may trigger antivirus will again attempt to dump a cached credentials
 while this technique will disable the ls a protection it does require that we upload the Mimi Dr. Sis driver to the victim machine which may trigger antivirus next will again attempt to dump a cached credentials
 according to the South put we have by pasteles a protection and have obtained the admin domain users ntlm hash
 in the next section will discuss how to dump Alsace memory without Mimi cats
processing credentials offline
 in this section will process the credentials offline by dumping the required memory section from the targets elsass and uploading it to a different Windows machine where we can safely extract the credentials this will help avoid detection since Mimi cats will neither be uploaded to nor run from the target machine
memory dump
 first we'll dump the process memory of elsass Windows allows us to create a dump file which is a snapshot of a given process this dump includes loaded libraries and application memory in this example will create the dump file with task manager to open task manager will right-click the taskbar and select it
 first we'll dump the process memory of Alsace Windows allows us to create a dump file which is a snapshot of a given process this dump includes loaded libraries and application memory in this example will create the dump file with task manager to open task manager will right-click the taskbar and select it
 next will navigate to the details Tab and locate the elsass. Exe process
 right-click it and choose create dump file
 after dumping the process memory the location of the dump file is presented in a pop-up
 what's the dump file is created we can copy it from the target to our local Windows client where we can parse it with Mimi cats in this example will stimulate offline parsing by copying the dump file to the Mimi cat's folder of the Windows 10 victim p.m. and will process it with Mimi cats there
 what's the dump file is created we can copy it from the target to our local Windows client where we can parse it with me me cats in this example will stimulate offline parsing by copying the dump file to the Mimi Katz folder of the Windows 10 victim p.m. and will process it with Mimi cats there
 first we'll run secure LS a mini dump supplying the name of the dump file to parse
 followed by sicurella say log on passwords to dump cached credentials
 this successfully dumps the admin domain users credentials and does not require Mimi cats on the target machine
 there is however one obvious disadvantage to this technique task manager cannot be run as a command line tool so we'll need gooey access to the Target alternatively we can create the dump file from the command line with crock dump from sysinternals
 since Proctor may also have a signature that could be recognized in the next section will build our own code to create the dump file
mini dump right dump
 in this section will develop our own C sharp application to execute of memory dump that we can parse with Mimi cats when task manager and Prok dump create a dump file they are invoking the win32 mini dump right dump API this means that we can write our own application in C sharp that does the same thing
 begin will go over the function prototype this function requires a lot of arguments but only the first four are needed for our use case the first two arguments must be a handle to Alsace and the process ID of elsass respectively the third argument is a handle to the file that will contain the generated memory dump and the fourth is an enumeration type which will set to mini dump with full memory or its numerical value of 2 to obtain a full memory dump
 with the foundational understanding of the API in place will create a visual Studio C sharp console app on the Windows 10 client called mini dump
 select release build
 and set the CPU architecture to 64-bit
 next we'll add the P invoke translated dllimport statement for mini dump right dump
 before we can call mini dump right dump we have to set up the four required arguments first will obtain the process ID of elsass and open a handle to it
 you get the process ID we can use the get processes by name method of the process class supplying the process named as a string and select the ID property we must include the system Diagnostics namespace to make use of the process class
 you got the process ID we can use the get processes by name method of the process class supplying the process named as a string and select the ID property we must include the system Diagnostics namespace to make use of the process class
 we can obtain a handle to the Alsace process with the win32 open process API just as we would with process injection will include the dllimport statement for open process and Supply the arguments for full access no inheritance and the process ID of elsass
 now that we have the first two arguments and place we must set up the dump file instead of using the win32 createfile API we can take advantage of the filestream class along with its Constructor
 do instantiate the file stream object we must Supply to arguments the name and full path of the file and the file mode create option indicating that we want to create a new file will also include the system IO namespace to use the file stream class
 now that we have all the pieces in place we can invoke a mini dump right file
 when supplying the file handle argument to mini dump right dump we must convert it to a c style file handle through the dangerous get handle method of the safe file handle class after compiling the project
 we can execute it from an elevated command prompt and generate a dump file
 with a dump file created we can run Mimi cats to parse it as we did in the last example
 the output reveals that are custom c-sharp application did in fact create a valid dump file for Alsace by stepping away from pre develop tools we have improved our trade craft and likely avoided antivirus detection
wrapping up
 in this module we discuss the various authentication mechanisms and privilege levels implemented in Windows and demonstrated various techniques and tools to obtain credentials and escalate our privileges